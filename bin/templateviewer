#!/usr/bin/env perl
use strict;
use warnings;

use Getopt::Long qw(GetOptionsFromArray :config gnu_getopt auto_version);
use Pod::Usage;
use Path::Class;
use Cwd;

use App::TemplateViewer;

use Plack::Builder;
use Plack::Runner;
use version 0.77; our $VERSION = qv("v0.1.0");

my @plackup_args = ();

sub parse_args {
    my @args = @_;
    my %h    = ();
    my @args_pattern
        = ( 'help|h', 'format|f=s', 'builder|b=s', 'data|d=s', 'target|t=s', 'port|p=i', 'static|s=s%' );
    $h{format} = 'tt2';
    if ( not GetOptionsFromArray( \@args, \%h, @args_pattern ) ) { pod2usage(2); return; }
    if ( exists $h{help} ) { pod2usage(1); return; }
    if ( not App::TemplateViewer->is_supported_format( $h{format} ) ) {
        printf STDERR "%s is not supported\n", $h{format};
        printf STDERR "supported type : %s\n", join q{ }, App::TemplateViewer->supported_format;
        return;
    }
    if ( exists $h{builder} ) {
        if ( not -f $h{builder} ) {
            print STDERR "$h{builder} is not found";
            return;
        }
    }
    if ( exists $h{static} and 'HASH' eq ref $h{static} ) {
        while ( my ( $k, $v ) = each %{ $h{static} } ) {
            if ( not -d $v ) {
                print STDERR "$v is not directory";
                return;
            }
            else {
                $v = dir($v)->absolute->resolve;
            }
        }
    }
    $h{target} ||= getcwd();
    if ( not -d $h{target} ) {
        printf STDERR "%s is not directory\n", $h{target};
        return;
    }
    else {
        $h{target} = dir( $h{target} )->absolute->resolve;
    }

    if ( @args > 0 ) {
        @plackup_args = @args;
    }

    # TODO temp
    $h{data} ||= '/tmp/templateviewer';

    # set plackup_args
    foreach my $k (qw(port)) {
        if ( exists $h{$k} ) {
            push @plackup_args, "--$k", delete $h{$k};
        }
    }
    return \%h;
}

sub build_static_path {
    my ( $app, $h ) = @_;
    while ( my ( $k, $v ) = each %$h ) {
        $app = Plack::Middleware::Static->wrap( $app, path => qr($k), root => $v );
    }
    $app;
}

# main

my $args = parse_args(@ARGV) or exit 0;

App::TemplateViewer::FileWatcher->new( watch => [ $args->{target} ] )->run;

my $app = App::TemplateViewer->run($args);

if ( exists $args->{static} ) {
    $app = build_static_path( $app, $args->{static} );
}
if ( exists $args->{builder} ) {
    $app = builder {
        do $args->{builder};
        $app;
    }
}

my $runner = Plack::Runner->new;
$runner->parse_options(@plackup_args);
$runner->run($app);

__END__

=pod

=head1 NAME

templateviewer - template viewer

=head1 SYNOPSIS

  templateviewer [options] [ -- [plackup options] ]

=head1 DESCRIPTION

templateviewer is template viewer

=head1 OPTIONS

=over 8

=item B<--target|-t> /path/to/target

set target directory. ( default: current directory )

=item B<--data|-d> /path/to/data/dir

set data directory. ( default: /tmp/templateviewer/ )

=item B<--format|-f> format

set default format type. ( default: tt2 )

=item B<--port|p> port_number

this option is passed to plackup

=item B<--static|s> path_info=path_to_file

this option can set multiple.

this option path to Plack::Middleware::Static like

  Plack::Middleware::Static->wrap($app, path => qr(path_info), root => 'path_to_file');

=item B<--builer|b> builder_file
 
builder file for set static file url. this file will do in builder block.

    #!perl
    use Plack::Builder;
    use File::Basename;
    use File::Spec;
    enable "Plack::Middleware::Static",
      path => qr{^/images|js|css|static/}, root => File::Spec->catfile(dirname(__FILE__), 'htdocs');

=item B<--help|-h>

show help

=item B<--version>

show version

=item B<--> plack options

you can pass options after B<--> to plackup

=back

=head1 AUTHOR

ywatase E<lt>ywatase@gmail.comE<gt>

=head1 SEE ALSO

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

# vim: set ft=perl:
